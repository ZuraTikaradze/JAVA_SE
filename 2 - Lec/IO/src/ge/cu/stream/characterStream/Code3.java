package ge.cu.stream.characterStream;

import java.io.*;

/*
 *   წავიკითხოთ ტექსტურ ფაილში ჩაწერილი ინფორმაცია და ჩავწეროთ მეორე ფაილში მასიური წაკითხვის გამოყენებით
 */
public class Code3 {
    public static void main(String[] args) {

        // წინა მაგალითებში ჩვენ გამოვიყენეთ ცალობითი წაკითხვა (read())
        // რისი ნელი მოქმედებაც შესამჩნევი იქნება თუ სიმბოლოების რაოდენობა დიდია
        // უფრო ეფექტური იქნება გამოვიყენოთ მასიური წაკითხვა

        // მაგრამ აქ საქმე ცოტა რთულადაა, ვიდრე ბაიტების შემთხვევაში.
        // ბაიტების წაკითხვისას ჩვენ ბაიტების რაოდენობა წინასწარ ვიცოდით - ფაილის ზომა
        // და ამ ზომის მასივს წინასწარ ვქმნიდით, თუმცა სიმბოლოებზე ეს არ ვიცით!
        // შეგვიძლია ასეთი რაღაც, ავიღოთ ფიქსირებული ზომის მასივი,
        // თუ ეყო ერთ წაკითხვას, მაშინ პრობლემაც არაფერი,
        // თუ არ ეყო - მაშინ წავიკითხავთ რამდენჯერმე.

        try (Reader reader = new FileReader("D:\\textfile.txt");
             Writer writer = new FileWriter("D:\\textfile copy.txt")) {

            // ავიღოთ 100 სიმბოლოიანი მასივი
            char[] chars = new char[100];

            // ეს ცვლადი უკვე იმისთვისაა, რომ დავიმახსოვროთ
            // მასივში ჩაკითხული სიმბოლოების -> რაოდენობა <-
            int readCharactersCount;

            // ვიყენებთ do-while ციკლს, რადგან პირველი წაკითხვა ყოველთვის საჭიროა
            do {
                // ვკითხულობთ მასივში სიმბოლოებს და მათ რაოდენობას ვინახავთ ცვლადში
                readCharactersCount = reader.read(chars);

                // ვწერთ სიმბოლოებს ნაკადში
                // თუმცა ერთპარამეტრიანი writer(chars) ნაცვლად
                // ვიყენებთ სამპარამეტრიანს - სადაც მიეთითება მასივის დასაწყისად
                // ასაღები ინდექსი, რომელიც სულ ნულია, და აი მეორე პარამეტრი,
                // რის გამოც ჩვენ ეს სამპარამეტრიანი დაგვჭირდა, არის რაოდენობა,
                // თუ ამ მასივიდან რამდენი ელემენტი გაიტანოს ნაკადში.
                // ამის მითითება საჭიროა, რადგან მასივი ყოველთვის სავსე არ იქნება
                // და ზედმეტი ელემენტები კი ნაკადში არ უნდა გავიტანოთ
                writer.write(chars, 0, readCharactersCount);

                // თუ წაკითხული სიმბოლოების რაოდენობა მასივში ჩაეტია, მაშინ, ბუნებრივია,
                // წაკითხული სიმბოლოების რაოდენობა უნდა იყოს ნაკლები მასივის ზომაზე
                // ხოლო თუ არ ჩაეტია - მაშინ კი მეტი, მაგრამ მეტი ვერ იქნება, იმიტომ რომ
                // ნაკადი იმაზე მეტს ვერ წაიკითხავდა რამდენიც მასივშია ადგილი, ასე რომ
                // მეტი კი არა ტოლია! და საჭიროა კიდევ წაკითხვა რომ წავიკითხოთ დანარჩენი
                // სიმბოლოებიც. ციკლიც სწორედ ამ შემთხვევაში ტრიალებს თავიდან -
                // როცა წაკითხული სიმბოლოების რაოდენობა ტოლია მასივის ზომის.
                // ხოლო როცა ნაკლებია, ეს, რა თქმა უნდა, ნიშნავს იმას რომ
                // მეტი სიმბოლო აღარცაა და ციკლის გაგრძელებაც აღარაა საჭირო
            } while (readCharactersCount == chars.length);

            // ყველა სიმბოლო გადაიწერება ერთი ფაილიდან მეორეში
            // თუმცა ეს არ ნიშნავს, იმას რომ თვითონ ფაილები იქნებიან
            // ერთიმეორის კოპიოები და იდენტურები. მათი მხოლოდ ტექსტი
            // იქნება ერთი და იგივე, ხოლო შეიძლება ფორმატით განსხვავდებოდნენ.
            // მაგალითად ერთი იყენებდეს 2 ბაიტიან სიმბოლოებს, ხოლო მეორე 1-ანებს
            // ამიტომ პირველის ზომა 2-ჯერ მეტი იქნება მეორისაზე, მიუხედავად იმის,
            // რომ ორივეში იდენტური ტექსტი წერია

        } catch (IOException e) {
            System.out.println("ფაილის გადაწერა ვერ მოხერხდა !!!");
            e.printStackTrace();
        }

    }
}

